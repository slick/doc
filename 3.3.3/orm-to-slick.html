<!DOCTYPE html>
<html class="no-js" lang="eng" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coming from ORM to Slick</title>
    <link rel="stylesheet" href="theme/css/foundation.min.css">
    <link rel="stylesheet" href="theme/css/app.css">
     <link rel="icon" href="favicon.ico" /> 
     <link rel="stylesheet" href="theme/highlight.js/styles/github-gist.css">  <link rel="stylesheet" href="theme/css/foundation-icons.custom.css"> 
    
     <link rel="prev" href="sql.html"  title="Plain SQL Queries"  />  <link rel="edit" href="https://github.com/slick/slick/blob/master/doc/src/orm-to-slick.md"  />  <link rel="next" href="sql-to-slick.html"  title="Coming from SQL to Slick"  />  <link rel="start" href="introduction.html"  title="Introduction"  />  <link rel="toc" href="index.html"  title="Slick"  />  <link rel="index" href="genindex.html"  title="Index"  /> 
  </head>
  <body>
    <div class="expanded row">
      <div class="small-12 medium-12 large-12 columns align-self-top">
        <div class="row">
          
          <header class="large-12 columns align-self-top a_header">
            <div class="row">
              <div class="large-12 columns a_limited top-bar">
                <div class="top-bar-left">
                  <p><img src="slick-logo.png" alt="Slick" /> <a class="a_vnav2" data-toggle="_id0">3.3.3</a><span class="dropdown-pane a_vnav2_pane" id="_id0"><span>Loading…</span></span> manual</p>

                </div>
                <div class="top-bar-right align-right row">
                  
                  
                    <form action="site-search.html" method="get" class="align-right a_search">
                      <input name="q" type="search"  placeholder="Search
" >
                      <button><img alt="&#1F50D;" src="theme/images/search.svg" /></button>
                    </form>
                  
                </div>
              </div>
            </div>
          </header>
          
          <div class="small-12 medium-12 large-12 columns align-self-top a_limited a_main">
            <div class="row">
              
              <main class="columns large-order-2 sections" id="_sections">
                 
  <ul class="menu align-right simple a_navbar a_navbar_top">
    
      
        <li><a href="sql.html"  title="Plain SQL Queries" ><span class="a_foundation_icon"></span>  Previous</a></li>
      
    
      
        <li><a href="sql-to-slick.html"  title="Coming from SQL to Slick" ><span class="a_foundation_icon"></span>  Next</a></li>
      
    
      
        <li><a href="https://github.com/slick/slick/blob/master/doc/src/orm-to-slick.md" ><span class="a_foundation_icon"></span>  Edit on GitHub</a></li>
      
    
      
        <li><a href="index.html"  title="Slick" ><span class="a_foundation_icon"></span>  Contents</a></li>
      
    
      
        <li><a href="genindex.html"  title="Index" ><span class="a_foundation_icon"></span>  Index</a></li>
      
    
  </ul>
 
                
                <h1 id="coming-from-orm-to-slick" class="a_section" data-magellan-target="coming-from-orm-to-slick">Coming from ORM to Slick<a class="a_hlink" href="#coming-from-orm-to-slick"></a></h1>
<h2 id="introduction" class="a_section" data-magellan-target="introduction">Introduction<a class="a_hlink" href="#introduction"></a></h2>
<p>Slick is not an object-relational mapper (ORM) like Hibernate or other <a href="http://en.wikipedia.org/wiki/Java_Persistence_API">JPA</a>-based products. Slick is a data persistence solution like ORMs and naturally shares some concepts, but it also has significant differences. This chapter explains the differences in order to help you get the best out of Slick and avoid confusion for those familiar with ORMs. We explain how Slick manages to avoid many of the problems often referred to as the object-relational impedance mismatch.</p>
<p>A good term to describe Slick is functional-relational mapper. Slick allows working with relational data much like with immutable collections and focuses on flexible query composition and strongly controlled side-effects. ORMs usually expose mutable object-graphs, use side-effects like read- and write-caches and hard-code support for anticipated use-cases like inheritance or relationships via association tables. Slick focuses on getting the best out of accessing a relational data store. ORMs focus on persisting an object-graph.</p>
<p>ORMs are a natural approach when using databases from object-oriented languages. They try to allow working with persisted object-graphs partly as if they were completely in memory. Objects can be modified, associations can be changed and the object graph can be traversed. In practice this is not exactly easy to achieve due to the so called object-relational impedance mismatch. It makes ORMs hard to implement and often complicated to use for more than simple cases and if performance matters. Slick in contrast does not expose an object-graph. It is inspired by SQL and the relational model and mostly just maps their concepts to the most closely corresponding, type-safe Scala features. Database queries are expressed using a restricted, immutable, purely-functional subset of Scala much like collections. Slick also offers <a href="sql.html">first-class SQL support</a> as an alternative.</p>
<p>In practice, ORMs often suffer from conceptual problems of what they try to achieve, from mere problems of the implementations and from mis-use, because of their complexity. In the following we look at many features of ORMs and what you would use with Slick instead. We’ll first look at how to work with the object graph. We then look at a series of particular features and use cases and how to handle them with Slick.</p>
<h2 id="configuration" class="a_section" data-magellan-target="configuration">Configuration<a class="a_hlink" href="#configuration"></a></h2>
<p>Some ORMs use extensive configuration files. Slick is configured using small amounts of Scala code. You have to provide information about how to <a href="database.html">connect to the database</a> and write or auto-generate a <a href="schemas.html">database schema</a> description if you want Slick to type-check your queries. Everything else like <a href="orm-to-slick.html#relationships">relationship definitions</a> beyond foreign keys are ordinary Scala code, which can use familiar abstraction methods for re-use.</p>
<h2 id="mapping-configuration" class="a_section" data-magellan-target="mapping-configuration">Mapping configuration<a class="a_hlink" href="#mapping-configuration"></a></h2>
<p>The later examples use the following database schema</p>
<p><img src="from-sql-to-slick.person-address.png" alt="" /></p>
<p>mapped to Slick using the following code:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Person</span> </span>= (<span class="hljs-type">Int</span>,<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>(<span class="hljs-params">tag: <span class="hljs-type">Tag</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Table</span>[<span class="hljs-type">Person</span>](<span class="hljs-params">tag, "<span class="hljs-type">PERSON</span>"</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">id</span> </span>= column[<span class="hljs-type">Int</span>](<span class="hljs-string">"ID"</span>, <span class="hljs-type">O</span>.<span class="hljs-type">PrimaryKey</span>, <span class="hljs-type">O</span>.<span class="hljs-type">AutoInc</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span> </span>= column[<span class="hljs-type">String</span>](<span class="hljs-string">"NAME"</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span> </span>= column[<span class="hljs-type">Int</span>](<span class="hljs-string">"AGE"</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addressId</span> </span>= column[<span class="hljs-type">Int</span>](<span class="hljs-string">"ADDRESS_ID"</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">*</span> </span>= (id,name,age,addressId)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">address</span> </span>= foreignKey(<span class="hljs-string">"ADDRESS"</span>,addressId,addresses)(_.id)
}
<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> people = <span class="hljs-type">TableQuery</span>[<span class="hljs-type">People</span>]

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Address</span> </span>= (<span class="hljs-type">Int</span>,<span class="hljs-type">String</span>,<span class="hljs-type">String</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Addresses</span>(<span class="hljs-params">tag: <span class="hljs-type">Tag</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Table</span>[<span class="hljs-type">Address</span>](<span class="hljs-params">tag, "<span class="hljs-type">ADDRESS</span>"</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">id</span> </span>= column[<span class="hljs-type">Int</span>](<span class="hljs-string">"ID"</span>, <span class="hljs-type">O</span>.<span class="hljs-type">PrimaryKey</span>, <span class="hljs-type">O</span>.<span class="hljs-type">AutoInc</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">street</span> </span>= column[<span class="hljs-type">String</span>](<span class="hljs-string">"STREET"</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">city</span> </span>= column[<span class="hljs-type">String</span>](<span class="hljs-string">"CITY"</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">*</span> </span>= (id,street,city)
}
<span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> addresses = <span class="hljs-type">TableQuery</span>[<span class="hljs-type">Addresses</span>]</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/SqlToSlick.scala#L12-L30" class="a_sourcelink">SqlToSlick.scala</a></div></div>
<p>Tables can alternatively be mapped to case classes. Similar code can be <a href="code-generation.html">auto-generated</a> or <a href="schemas.html">hand-written</a>.</p>
<p>In ORMs you often provide your mapping specification in a configuration file. In Slick you provide it as Scala types like above, which are used to type-check Slick queries. A difference is that the Slick mapping is conceptually very simple. It only describes database tables and optionally maps rows to case classes or something else using arbitrary factories and extractors. It does contain information about foreign keys, but nothing else about <a href="orm-to-slick.html#relationships">relationships</a> or other patterns. These are mapped using re-usable queries fragments instead.</p>
<h2 id="navigating-the-object-graph" class="a_section" data-magellan-target="navigating-the-object-graph">Navigating the object graph<a class="a_hlink" href="#navigating-the-object-graph"></a></h2>
<h3 id="using-plain-old-method-calls" class="a_section" data-magellan-target="using-plain-old-method-calls">Using plain old method calls<a class="a_hlink" href="#using-plain-old-method-calls"></a></h3>
<p>This chapter could also be called strict vs. lazy or imperative vs. declarative. One common feature ORMs provide is using a persisted object graph just as if it was in-memory. And since it is not, artifacts like members or related objects are usually loaded ad-hoc only when they are needed. To make this happen, ORMs implement or intercept method calls, which look like they happen in-memory, but instead execute database queries as needed to return the desired results. Let’s look at an example using a hypothetical ORM:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> people: <span class="hljs-type">Seq</span>[<span class="hljs-type">Person</span>] = <span class="hljs-type">PeopleFinder</span>.getByIds(<span class="hljs-type">Seq</span>(<span class="hljs-number">2</span>,<span class="hljs-number">99</span>,<span class="hljs-number">17</span>,<span class="hljs-number">234</span>))
<span class="hljs-keyword">val</span> addresses: <span class="hljs-type">Seq</span>[<span class="hljs-type">Address</span>] = people.map(_.address)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L59-L60" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>How many database round trips does this require? In fact reasoning about this question for different code is one of the things you need to devote the most time to when learning the collections-like API of an ORM. What usually happens is, that the ORM would do an immediate database round trip for <code class="hljs">getByIds</code> and return the resulting people. Then <code class="hljs">map</code> would be a Scala List method and <code class="hljs">.map(_.address)</code> accesses the <code class="hljs">address</code> of each person. An ORM would witness the <code class="hljs">address</code> accesses one-by-one not knowing upfront that they happen in a loop. This often leads to an additional database round trip for each person, which is not ideal (n+1 problem), because database round trips are expensive. To solve the problem, ORMs often provide means to work around this, by basically telling them about the future, so they can aggregate multiple upcoming round trips into fewer more efficient ones.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala">                          <span class="hljs-comment">// tell the ORM to load all related addresses at once</span>
<span class="hljs-keyword">val</span> people: <span class="hljs-type">Seq</span>[<span class="hljs-type">Person</span>] = <span class="hljs-type">PeopleFinder</span>.getByIds(<span class="hljs-type">Seq</span>(<span class="hljs-number">2</span>,<span class="hljs-number">99</span>,<span class="hljs-number">17</span>,<span class="hljs-number">234</span>)).prefetch(_.address)
<span class="hljs-keyword">val</span> addresses: <span class="hljs-type">Seq</span>[<span class="hljs-type">Address</span>] = people.map(_.address)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L64-L66" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>Here the prefetch method instructs the hypothetical ORM to load all addresses immediately with the people, often in only one or two database round trips. The addresses are then stored in a cache many ORMs maintain. The later <code class="hljs">.map(_.address)</code> call could then be fully served from the cache. Of course this is redundant as you basically need to provide the mapping to addresses twice and if you forget to prefetch you will have poor performance. How you specify the pre-fetching rules depends on the ORM, often using external configuration or inline like here.</p>
<p>Slick works differently. To do the same in Slick you would write the following. The type annotations are optional but shown here for clarity.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> peopleQuery: <span class="hljs-type">Query</span>[<span class="hljs-type">People</span>,<span class="hljs-type">Person</span>,<span class="hljs-type">Seq</span>] = people.filter(_.id inSet(<span class="hljs-type">Set</span>(<span class="hljs-number">2</span>,<span class="hljs-number">99</span>,<span class="hljs-number">17</span>,<span class="hljs-number">234</span>)))
<span class="hljs-keyword">val</span> addressesQuery: <span class="hljs-type">Query</span>[<span class="hljs-type">Addresses</span>,<span class="hljs-type">Address</span>,<span class="hljs-type">Seq</span>] = peopleQuery.flatMap(_.address)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L72-L73" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>As we can see it looks very much like collection operations but the values we get are of type <code class="hljs">Query</code>. They do not
store results, only a plan of the operations that are needed to create a SQL query that produces the results when
needed. No database round trips happen at all in our example. To actually fetch results, we have to compile the
query to a <a href="database.html">database Action</a> with <code class="hljs">.result</code> and then <code class="hljs">run</code> it on the Database.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> addressesAction: <span class="hljs-type">DBIO</span>[<span class="hljs-type">Seq</span>[<span class="hljs-type">Address</span>]] = addressesQuery.result
<span class="hljs-keyword">val</span> addresses: <span class="hljs-type">Future</span>[<span class="hljs-type">Seq</span>[<span class="hljs-type">Address</span>]] = db.run(addressesAction)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L76-L77" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>A single query is executed and the results returned. This makes database round trips very explicit and easy to reason about. Achieving few database round trips is easy.</p>
<p>As you can see with Slick we do not navigate the object graph (i.e. results) directly. We navigate it by composing
queries instead, which are just place-holder values for potential database round trip yet to happen. We can lazily
compose queries until they describe exactly what we need and then use a single <code class="hljs">Database.run</code> call for execution.</p>
<p>Navigating the object graph directly in an ORM is problematic as explained earlier. Slick gets away without that feature. ORMs often solve the problem by offering a declarative query language as an alternative, which is similar to how you work with Slick.</p>
<h3 id="query-languages" class="a_section" data-magellan-target="query-languages">Query languages<a class="a_hlink" href="#query-languages"></a></h3>
<p>ORMs often come with declarative query languages like JPA’s JQL or Criteria API. Similar to SQL or Slick, they allow expressing queries yet to happen and make execution explicit.</p>
<h4 id="string-based-embeddings" class="a_section">String based embeddings<a class="a_hlink" href="#string-based-embeddings"></a></h4>
<p>Quite commonly,  these languages, for example HQL, but also SQL are embedded into programs as Strings. Here is an example for HQL.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> hql: <span class="hljs-type">String</span> = <span class="hljs-string">"FROM Person p WHERE p.id in (:ids)"</span>
<span class="hljs-keyword">val</span> q: <span class="hljs-type">Query</span> = session.createQuery(hql)
q.setParameterList(<span class="hljs-string">"ids"</span>, <span class="hljs-type">Array</span>(<span class="hljs-number">2</span>,<span class="hljs-number">99</span>,<span class="hljs-number">17</span>,<span class="hljs-number">234</span>))</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L83-L85" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>Strings are a very simple way to embed an arbitrary language and in many programming languages the only way without changing the compiler, for example in Java. While simple, this kind of embedding has significant limitations.</p>
<p>One issue is that tools often have no knowledge about the embedded language and treat queries as ordinary Strings. The compilers or interpreters of the host languages do not detect syntactical mistakes upfront or if the query produces a different type of result than expected. Also IDEs often do not provide syntax highlighting, code completion, inline error hints, etc.</p>
<p>More importantly, re-use is very hard. You would need to compose Strings in order to re-use certain parts of queries. As an exercise, try to make the id filtering part of our above HQL example re-useable, so we can use it for table person as well as address. It is really cumbersome.</p>
<p>In Java and many other languages, strings are the only way to embed a concise query language. As we will see in the next sections, Scala is more flexible.</p>
<h4 id="method-based-apis" class="a_section">Method based APIs<a class="a_hlink" href="#method-based-apis"></a></h4>
<p>Instead of getting the ultimate flexibility for the embedded language, an alternative approach is to go with the extensibility features of the host language and use those. Object-oriented languages like Java and Scala allow extensibility through the definition of APIs consisting of objects and methods. JPA’s Criteria API use this concept and so does Slick. This allows the host language tools to partially understand the embedded language and provide better support for the features mentioned earlier. Here is an example using Criteria Queries.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> id = <span class="hljs-type">Property</span>.forName(<span class="hljs-string">"id"</span>)
<span class="hljs-keyword">val</span> q = session.createCriteria(classOf[<span class="hljs-type">Person</span>])
               .add( id in <span class="hljs-type">Array</span>(<span class="hljs-number">2</span>,<span class="hljs-number">99</span>,<span class="hljs-number">17</span>,<span class="hljs-number">234</span>) )</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L89-L91" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>A method based embedding makes queries compositional. Factoring out filtering by ids becomes easy:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">byIds</span></span>(c: <span class="hljs-type">Criteria</span>, ids: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>]) = c.add( id in ids )

<span class="hljs-keyword">val</span> c = byIds(
  session.createCriteria(classOf[<span class="hljs-type">Person</span>]),
  <span class="hljs-type">Array</span>(<span class="hljs-number">2</span>,<span class="hljs-number">99</span>,<span class="hljs-number">17</span>,<span class="hljs-number">234</span>)
)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L94-L99" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>Of course ids are a trivial example, but this becomes very useful for more complex queries.</p>
<p>Java APIs like JPA‘s Criteria API do not use Scala’s operator overloading capabilities. This can lead to more cumbersome and less familiar code when expressing queries. Let’s query for all people younger 5 or older than 65 for example.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> age = <span class="hljs-type">Property</span>.forName(<span class="hljs-string">"age"</span>)
<span class="hljs-keyword">val</span> q = session.createCriteria(classOf[<span class="hljs-type">Person</span>])
               .add(
                 <span class="hljs-type">Restrictions</span>.disjunction
                   .add(age lt <span class="hljs-number">5</span>)
                   .add(age gt <span class="hljs-number">65</span>)
               )</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L103-L109" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>With Scala‘s operator overloading we can do better and that’s what Slick uses. Queries are very concise. The same query in Slick would look like this:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> q = people.filter(p =&gt; p.age &lt; <span class="hljs-number">5</span> || p.age &gt; <span class="hljs-number">65</span>)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L113" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>There are some limitations to Scala’s overloading capabilities that affect Slick. In queries, one has to use <code class="hljs">===</code> instead of <code class="hljs">==</code>, <code class="hljs">=!=</code> instead of <code class="hljs">!=</code> and <code class="hljs">++</code> for string concatenation instead of <code class="hljs">+</code>.  Also it is not possible to overload <code class="hljs">if</code> expressions in Scala. Instead Slick comes with a small <a href="sql-to-slick.html#case">DSL for SQL case expressions</a>.</p>
<p>As already mentioned, we are working with placeholder values, merely describing the query, not executing it. Here’s the same expression again with added type annotations to allow us looking behind the scenes a bit:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> q = (people: <span class="hljs-type">Query</span>[<span class="hljs-type">People</span>, <span class="hljs-type">Person</span>, <span class="hljs-type">Seq</span>]).filter(
  (p: <span class="hljs-type">People</span>) =&gt;
    (
      ((p.age: <span class="hljs-type">Rep</span>[<span class="hljs-type">Int</span>]) &lt; <span class="hljs-number">5</span> || p.age &gt; <span class="hljs-number">65</span>)
      : <span class="hljs-type">Rep</span>[<span class="hljs-type">Boolean</span>]
    )
)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L117-L123" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p><code class="hljs">Query</code> marks collection-like query expressions, e.g. a whole table. <code class="hljs">People</code> is the Slick Table subclass defined for table person. In this context it may be confusing that the value is used rather as a prototype for a row here. It has members of type <code class="hljs">Rep</code> representing the individual columns. Expressions based on these columns result in other expressions of type <code class="hljs">Rep</code>. Here we are using several <code class="hljs">Rep[Int]</code> to compute a <code class="hljs">Rep[Boolean]</code>, which we are using as the filter expression. Internally, Slick builds a tree from this, which represents the operations and is used to produce the corresponding SQL code. We often call this process of building up expression trees encapsulated in place-holder values as lifting expressions, which is why we also call this query interface the <em>lifted embedding</em> in Slick.</p>
<p>It is important to note that Scala allows to be very type-safe here. E.g. Slick supports a method <code class="hljs">.substring</code> for <code class="hljs">Rep[String]</code> but not for <code class="hljs">Rep[Int]</code>. This is impossible in Java and Java APIs like Criteria Queries, but possible in Scala using type-parameter based method extensions via implicits. This allows tools like the Scala compiler and IDEs to understand the code much more precisely and offer better checking and support.</p>
<p>A nice property of a Slick-like query language is that it can be used with Scala’s comprehension syntax, which is just Scala-builtin syntactic sugar for collections operations. The above example can alternatively be written as</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">for</span>( p &lt;- people <span class="hljs-keyword">if</span> p.age &lt; <span class="hljs-number">5</span> || p.age &gt; <span class="hljs-number">65</span> ) <span class="hljs-keyword">yield</span> p</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L127" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>Scala’s comprehension syntax looks much like SQL or ORM query languages. It however lacks syntactic support for some constructs like sorting and grouping, for which one has to use the method-based api, e.g.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala">( <span class="hljs-keyword">for</span>( p &lt;- people <span class="hljs-keyword">if</span> p.age &lt; <span class="hljs-number">5</span> || p.age &gt; <span class="hljs-number">65</span> ) <span class="hljs-keyword">yield</span> p ).sortBy(_.name)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L131" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>Despite the syntactic limitations, the comprehension syntax is convenient when dealing with multiple inner joins.</p>
<p>It is important to note that the problems of method-based query APIs like Criteria Queries described above are not a conceptual limitation of ORM query languages but merely an artifact of many ORMs being Java frameworks. In principle, Scala ORMs could offer a query language just like Slick‘s and they should. Comfortably compositional queries allow for a high degree of code re-use. They seem to be Slick’s favorite feature for many developers.</p>
<h4 id="macro-based-embeddings" class="a_section">Macro-based embeddings<a class="a_hlink" href="#macro-based-embeddings"></a></h4>
<p>Scala macros allow other approaches for embedding queries. They can be used to check queries embedded as Strings at compile time. They can also be used to translate Scala code written without Query and Rep place holder types to SQL. Both approaches are being prototyped and evaluated for Slick but are not ready for prime-time yet. There are other database libraries out there that already use macros for their query language.</p>
<h2 id="query-granularity" class="a_section" data-magellan-target="query-granularity">Query granularity<a class="a_hlink" href="#query-granularity"></a></h2>
<p>With ORMs it is not uncommon to treat objects or complete rows as the smallest granularity when loading data. This is not necessarily a limitation of the frameworks, but a habit of using them. With Slick it is very much encouraged to only fetch the data you actually need. While you can map rows to classes with Slick, it is often more efficient to not use that feature, but to restrict your query to the data you actually need in that moment. If you only need a person’s name and age, just map to those and return them as a tuple.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala">people.map(p =&gt; (p.name, p.age))</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L135" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>This allows you to be very precise about what data is actually transferred.</p>
<h2 id="read-caching" class="a_section" data-magellan-target="read-caching">Read caching<a class="a_hlink" href="#read-caching"></a></h2>
<p>Slick doesn’t cache query results. Working with Slick is like working with JDBC in this regard. Many ORMs come with read and write caches. Caches are side-effects. They can be hard to reason about. It can be tricky to manage cache consistency and lifetime.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-type">PeopleFinder</span>.getById(<span class="hljs-number">5</span>)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L139" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>This call may be served from the database or from a cache. It is not clear at the call site what the performance is. With Slick it is very clear that executing a query leads to a database round trip and that Slick doesn’t interfere with member accesses on objects.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala">db.run(people.filter(_.id === <span class="hljs-number">5</span>).result)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L144" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>Slick returns a consistent, immutable snapshot of a fraction of the database at that point in time. If you need consistency over multiple queries, use transactions.</p>
<h2 id="writes-and-caching" class="a_section" data-magellan-target="writes-and-caching">Writes (and caching)<a class="a_hlink" href="#writes-and-caching"></a></h2>
<p>Writes in many ORMs require write caching to be performant.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> person = <span class="hljs-type">PeopleFinder</span>.getById(<span class="hljs-number">5</span>)
person.name = <span class="hljs-string">"C. Vogt"</span>
person.age = <span class="hljs-number">12345</span>
session.save</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L149-L160" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>Here our hypothetical ORM records changes to the object and the <code class="hljs">.save</code> method syncs back changes into the database in a single round trip rather than one per member. In Slick you would do the following instead:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> personQuery = people.filter(_.id === <span class="hljs-number">5</span>)
personQuery.map(p =&gt; (p.name,p.age)).update(<span class="hljs-string">"C. Vogt"</span>, <span class="hljs-number">12345</span>)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L164-L165" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>Slick embraces declarative transformations. Rather than modifying individual members of objects one after the other, you state all modifications at once and Slick creates a single database round trip from it without using a cache. New Slick users seem to be often confused by this syntax, but it is actually very neat. Slick unifies the syntax for queries, inserts, updates and deletes. Here <code class="hljs">personQuery</code> is just a query. We could use it to fetch data. But instead, we can also use it to update the columns specified by the query. Or we can use it do delete the rows.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala">personQuery.delete <span class="hljs-comment">// deletes person with id 5</span></code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L169" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>For inserts, we insert into the query, that resembles the whole table and can select individual columns in the same way.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala">people.map(p =&gt; (p.name,p.age)) += (<span class="hljs-string">"S. Zeiger"</span>, <span class="hljs-number">54321</span>)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L173" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<h2 id="relationships" class="a_section" data-magellan-target="relationships">Relationships<a class="a_hlink" href="#relationships"></a></h2>
<p>ORMs usually provide built-in, hard-coded support for 1-to-many and many-to-many relationships. They can be set up centrally in the configuration. In SQL on the other hand you would specify them using joins in every single query. You have a lot of flexibility what you join and how. With Slick you get the best of both worlds. Slick queries are as flexible as SQL, but also compositional. You can store fragments like join conditions in central places and use language-level abstraction. Relationships of any sort are just one thing you can naturally abstract over like in any Scala code. There is no need for Slick to hard-code support for certain use cases. You can easily implement arbitrary use cases yourself, e.g. the common 1-n or n-n relationships or even relationships spanning over multiple tables, relationships with additional discriminators, polymorphic relationships, etc.</p>
<p>Here is an example for person and addresses.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonExtensions</span>[<span class="hljs-type">C</span>[_]](<span class="hljs-params">q: <span class="hljs-type">Query</span>[<span class="hljs-type">People</span>, <span class="hljs-type">Person</span>, <span class="hljs-type">C</span>]</span>) </span>{
  <span class="hljs-comment">// specify mapping of relationship to address</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">withAddress</span> </span>= q.join(addresses).on(_.addressId === _.id)
}

<span class="hljs-keyword">val</span> chrisQuery = people.filter(_.id === <span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> stefanQuery = people.filter(_.id === <span class="hljs-number">3</span>)

<span class="hljs-keyword">val</span> chrisWithAddress: <span class="hljs-type">Future</span>[(<span class="hljs-type">Person</span>, <span class="hljs-type">Address</span>)] =
  db.run(chrisQuery.withAddress.result.head)
<span class="hljs-keyword">val</span> stefanWithAddress: <span class="hljs-type">Future</span>[(<span class="hljs-type">Person</span>, <span class="hljs-type">Address</span>)] =
  db.run(stefanQuery.withAddress.result.head)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L178-L192" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>A common question for new Slick users is how they can follow a relationship on a result. In an ORM you could do something like this:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> chris: <span class="hljs-type">Person</span> = <span class="hljs-type">PeopleFinder</span>.getById(<span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> address: <span class="hljs-type">Address</span> = chris.address</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L198-L199" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>As explained earlier, Slick does not allow navigating the object-graph as if data was in memory, because of the problem that comes with it. Instead of navigating relationships on results you write new queries instead.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> chrisQuery: <span class="hljs-type">Query</span>[<span class="hljs-type">People</span>,<span class="hljs-type">Person</span>,<span class="hljs-type">Seq</span>] = people.filter(_.id === <span class="hljs-number">2</span>)
<span class="hljs-keyword">val</span> addressQuery: <span class="hljs-type">Query</span>[<span class="hljs-type">Addresses</span>,<span class="hljs-type">Address</span>,<span class="hljs-type">Seq</span>] = chrisQuery.withAddress.map(_._2)
<span class="hljs-keyword">val</span> address = db.run(addressQuery.result.head)</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L210-L212" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>If you leave out the optional type annotation and some intermediate vals it is very clean. And it is very clear where database round trips happen.</p>
<p>A variant of this question Slick new comers often ask is how they can do something like this in Slick:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span>(<span class="hljs-params"> … </span>)</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params"> …, address: <span class="hljs-type">Address</span> </span>)</span></code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L204-L205" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>The problem is that this hard-codes that a Person requires an Address. It cannot be loaded without it. This doesn‘t fit to Slick’s philosophy of giving you fine-grained control over what you load exactly. With Slick it is advised to map one table to a tuple or case class without them having object references to related objects. Instead you can write a function that joins two tables and returns them as a tuple or association case class instance, providing an association externally, not strongly tied one of the classes.</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> tupledJoin: <span class="hljs-type">Query</span>[(<span class="hljs-type">People</span>,<span class="hljs-type">Addresses</span>),(<span class="hljs-type">Person</span>,<span class="hljs-type">Address</span>), <span class="hljs-type">Seq</span>]
      = people join addresses on (_.addressId === _.id)

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonWithAddress</span>(<span class="hljs-params">person: <span class="hljs-type">Person</span>, address: <span class="hljs-type">Address</span></span>)</span>
<span class="hljs-keyword">val</span> caseClassJoinResults = db.run(tupledJoin.result).map(_.map(<span class="hljs-type">PersonWithAddress</span>.tupled))</code></pre>
<a href="https://github.com/slick/slick/blob/v3.3.3/doc/code/OrmToSlick.scala#L218-L222" class="a_sourcelink">OrmToSlick.scala</a></div></div>
<p>An alternative approach is giving your classes Option-typed members referring to related objects, where None means that the related objects have not been loaded yet. However this is less type-safe than using a tuple or case class, because it cannot be statically checked, if the related object is loaded.</p>
<h3 id="modifying-relationships" class="a_section" data-magellan-target="modifying-relationships">Modifying relationships<a class="a_hlink" href="#modifying-relationships"></a></h3>
<p>When manipulating relationships with ORMs you usually work on mutable collections of associated objects and inserts or remove related objects. Changes are written to the database immediately or recorded in a write cache and committed later. To avoid stateful caches and mutability, Slick handles relationship manipulations just like SQL - using foreign keys. Changing relationships means updating foreign key fields to new ids, just like updating any other field. As a bonus this allows establishing and removing associations with objects that have not been loaded into memory. Having their ids is sufficient.</p>
<h2 id="inheritance" class="a_section" data-magellan-target="inheritance">Inheritance<a class="a_hlink" href="#inheritance"></a></h2>
<p>Slick does not persist arbitrary object-graphs. It rather exposes the relational data model nicely integrated into Scala. As the relational schema doesn‘t contain inheritance so doesn’t Slick. This can be unfamiliar at first. Usually inheritance can be simply replaced by relationships thinking along the lines of roles. Instead of foo is a bar think foo has role bar. As Slick allows query composition and abstraction, inheritance-like query-snippets can be easily implemented and put into functions for re-use. Slick doesn’t provide any out of the box but allows you to flexibly come up with the ones that match your problem and use them in your queries.</p>
<h2 id="code-generation" class="a_section" data-magellan-target="code-generation">Code-generation<a class="a_hlink" href="#code-generation"></a></h2>
<p>Many of the concepts described above can be abstracted over using Scala code to avoid repetition. There cases however, where you reach the limits of Scala‘s type system’s abstraction capabilities. Code generation offers a solution to this. Slick comes with a very flexible and fully customizable <a href="code-generation.html">code generator</a>, which can be used to avoid repetition in these cases. The code generator operates on the meta data of the database. Combine it with your own extra meta data if needed and use it to generate Slick types, relationship accessors, association classes, etc. For more info see our Scala Days 2014 talk at <a href="http://slick.typesafe.com/docs/">http://slick.typesafe.com/docs/</a>.</p>

                 
  <ul class="menu align-right simple a_navbar a_navbar_bottom">
    
      
        <li><a href="sql.html"  title="Plain SQL Queries" ><span class="a_foundation_icon"></span>  Previous</a></li>
      
    
      
        <li><a href="sql-to-slick.html"  title="Coming from SQL to Slick" ><span class="a_foundation_icon"></span>  Next</a></li>
      
    
      
        <li><a href="https://github.com/slick/slick/blob/master/doc/src/orm-to-slick.md" ><span class="a_foundation_icon"></span>  Edit on GitHub</a></li>
      
    
      
        <li><a href="index.html"  title="Slick" ><span class="a_foundation_icon"></span>  Contents</a></li>
      
    
      
        <li><a href="genindex.html"  title="Index" ><span class="a_foundation_icon"></span>  Index</a></li>
      
    
  </ul>
 
              </main>
              
              
                <div data-sticky-container class="small-12 medium-12 large-2 large-order-1 columns a_sitenav_container">
                  <nav class="a_sitenav" data-sticky data-sticky-on="large" data-anchor="_sections">
                    
                    <ul>
                       
  <li >
    
      
        <a href="introduction.html">Introduction</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="supported-databases.html">Supported Databases</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="gettingstarted.html">Getting Started</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="concepts.html">Core Concepts</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="database.html">Database Configuration</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="dbio.html">Database I/O Actions</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="schemas.html">Schemas</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="queries.html">Queries</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="code-generation.html">Schema Code Generation</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="userdefined.html">User-Defined Features</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="sql.html">Plain SQL Queries</a>
      
    
    
  </li>
  
  <li  class="a_thispage" >
    
      
        <a href="orm-to-slick.html">Coming from ORM to Slick</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="sql-to-slick.html">Coming from SQL to Slick</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="cookbook.html">Cookbook</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="upgrade.html">Upgrade Guides</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="migrations.html">Database Migrations</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="testkit.html">Slick TestKit</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="documentation.html">Markdown Documentation</a>
      
    
    
  </li>
  
  <li >
    
      
        <a href="config.html">Configuration</a>
      
    
    
  </li>
 
                    </ul>
                    
                    
                  </nav>
                </div>
              
              
              
                <div class="small-12 medium-12 large-2 large-order-3 columns a_show-for-xlarge" data-sticky-container>
                  <nav class="a_pagenav" data-sticky data-sticky-on="large" data-anchor="_sections">
                     <header><p>On This Page</p>
</header> 
                    <ul class="vertical menu" data-magellan>
                       
  
    <li>
      
         <a href="#coming-from-orm-to-slick">Coming from ORM to Slick</a> 
      
      
        <ul class="vertical menu">  
  
    <li>
      
         <a href="#introduction">Introduction</a> 
      
      
    </li>
  
  
  
    <li>
      
         <a href="#configuration">Configuration</a> 
      
      
    </li>
  
  
  
    <li>
      
         <a href="#mapping-configuration">Mapping configuration</a> 
      
      
    </li>
  
  
  
    <li>
      
         <a href="#navigating-the-object-graph">Navigating the object graph</a> 
      
      
        <ul class="vertical menu">  
  
    <li>
      
         <a href="#using-plain-old-method-calls">Using plain old method calls</a> 
      
      
    </li>
  
  
  
    <li>
      
         <a href="#query-languages">Query languages</a> 
      
      
    </li>
  
  </ul>
      
    </li>
  
  
  
    <li>
      
         <a href="#query-granularity">Query granularity</a> 
      
      
    </li>
  
  
  
    <li>
      
         <a href="#read-caching">Read caching</a> 
      
      
    </li>
  
  
  
    <li>
      
         <a href="#writes-and-caching">Writes (and caching)</a> 
      
      
    </li>
  
  
  
    <li>
      
         <a href="#relationships">Relationships</a> 
      
      
        <ul class="vertical menu">  
  
    <li>
      
         <a href="#modifying-relationships">Modifying relationships</a> 
      
      
    </li>
  
  </ul>
      
    </li>
  
  
  
    <li>
      
         <a href="#inheritance">Inheritance</a> 
      
      
    </li>
  
  
  
    <li>
      
         <a href="#code-generation">Code-generation</a> 
      
      
    </li>
  
  </ul>
      
    </li>
  
 
                    </ul>
                  </nav>
                </div>
              
            </div>
          </div>
        </div>
      </div>
      
      <footer class="small-12 medium-12 large-12 columns align-self-bottom a_footer">
        <div class="row">
          <div class="small-12 medium-12 large-12 columns top-bar">
            <div class="top-bar-left">
              <p>© Copyright 2011-2019 Lightbend, Inc.</p>

            </div>
            <div class="top-bar-right">
              <p>Generated with <a href="https://github.com/szeiger/ornate">Ornate</a>.</p>

            </div>
          </div>
        </div>
      </footer>
    </div>
    
      <div style="display: none">
        <a href="../" id="_version_idx"></a>
        <a href="./" id="_site_root"></a>
      </div>
    
    <script src="theme/js/jquery.min.js"></script>
    <script src="theme/js/what-input.min.js"></script>
    <script src="theme/js/foundation.min.js"></script>
    
    <script src="theme/js/app.js"></script>
    
  </body>
</html>
